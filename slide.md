---
marp: true
theme: default
style: |
  section {
    font-family: 'Arial', sans-serif;
    color: #333;
  }
  h1 {
    color: #00509E;
    border-bottom: 2px solid #00509E;
    position: fixed;
    top: 50px;
    background: white;
    z-index: 1000;
  }
  h2 {
    color: #333;
  }
  h3 {
    color: #666;
  }
  .author, .affiliation, .date {
    font-size: 0.8em;
    color: #666;
  }
  .flex-container {
    display: flex;
    justify-content: space-around;
    align-items: flex-start; /* 画像を上に揃える */
    margin-top: 20px; /* 上部の余白を調整 */
  }
  img {
    max-height: 337px;
  }
---
## WebSocketを用いた双方向通信を実現するWebアプリケーションの開発手法とその検証

### 発表者: 202103318 儀賀真周
### 所属: 神奈川大学 理学部 情報科学科

<!-- これからWebSocketを用いた双方向通信を実現するWebアプリケーションの開発手法とその検証の発表を行います -->

---
# 研究背景
## 不可欠な通信プロトコル HTTP と課題

- HTTP通信はハイパーテキスト文章・画像・動画・PDFなど、さまざまなメディアタイプでのデータの受け渡しを**Web上で行うことが可能**
→ 欠かせない通信技術の一つ

- リモート会議・講義など遠隔でリアルタイムな通信も求められる時代となった
→ HTTPは通信設計上リアルタイムの通信には不向き
（常に通信するのではなく、リクエスト駆動形式で通信を開始するたびに接続の確立を行うため、リアルタイム通信を実現しようとすると膨大なリソースを要する）

<!-- はじめに研究背景です。現代におけるHTTP通信は非常に不可欠な通信プロトコルで、Webを通してハイパーテキスト文章・画像・動画・PDFのようなファイル等のデータのやりとりを行うことができます。
しかし昨今ではリモート会議・講義等でよりリアルタイムな通信が重視されるようになりました。
HTTPは設計上リアルタイムな通信には不向きであり、現代のニーズに応えることが難しいということですが、Webでもリアルタイムな通信が行えるようになることでよりWebというプラットフォームの幅が広がることになります。
 -->

---
# 研究背景
## WebSocketプロトコル：Web上でリアルタイム処理を実現
### WebSocketとは
- HTTPを用いて通信を確立した後、常にサーバーとクライアントの双方向な通信を低コストで実現する通信プロトコル
→ 常時サーバーから最新の情報を受信可能になるため、チャットサービス、リアルタイム共同編集ツール（Figma、Google スプレッドシートなど）が普及

<!-- そこで、WebSocketプロトコルを用いることにより、Web上でリアルタイムな通信を実装することができます。
WebSocketとは、HTTPを用いて通信を確立した後、常にサーバーとクライアントの双方向な通信を低コストで実現する通信プロトコルとなります。
そしてこのプロトコルにより、Web上でチャットサービスやリアルタイム共同編集ツールのGoogleスプレッドシートやFigmaなどが普及し始めています。
 -->

---
# 研究目的

## 1. WebSocketを実装するWebアプリケーション開発の手法

## 2. WebSocket通信によるパフォーマンス変化の検証
開発したWebアプリケーションを実際に使用した場合による通信の速度パフォーマンスを計測し有用性を測る

<!-- そこで本研究では、実際にWebSocketを利用してWebアプリケーションを実装するためにはどのように開発するのかを知り、さらにWebSocket通信によるパフォーマンスの検証を行います -->

---
# 作成したWebアプリケーション
## リアルタイム投票アプリ
- ホストとなるユーザーを一人、ゲストは複数人
- ホストが投票ルームを作成し、ゲストはその投票ルームに参加
- ホストが事前に用意した選択式の設問にゲストは回答
- ホストはゲストの回答をリアルタイムで閲覧することができ、任意のタイミングで回答の集計を行い、統計データを全ユーザー閲覧することができる


## 使用した技術
JavaScript, TypeScript, Svelte, HTML, CSS

<!-- 次に作成したWebアプリケーションの紹介です。今回、リアルタイム投票アプリというものを作成しました。まずホストとなるユーザーを一人、ゲストを複数人用意します。続いて、ホストが投票ルームというものを作成し、ゲストはその投票ルームに参加します。そして、ホストが事前に用意した設問にゲストは回答していきます。この時、ホストはゲストの回答をリアルタイムで閲覧することができ、また任意のタイミングで回答の集計を行い、統計データを全ユーザにリアルタイムで共有することができます。
 -->

---
# 実際の画面
## 投票ルーム作成後ホスト画面

![bg right:47%](host_vote_page_home.png)
- QRコード or 招待URLから<br>ゲストは投票ルームにアクセス可能

<!-- 実際の画面がこちらになります。投票ルーム作成後のホスト側の画面で、QRコードとURLが表示されます。このどちらかをゲストに共有することでホストが作成した投票ルームに参加することができます。 -->

---
# 実際の画面
## ゲスト側投票中画面

![bg contain right](guest_mobile_voting_page.PNG)
- ホストが事前に作成した設問に回答（選択式）

<!-- 実際に投票が始まるとゲストはこの画像のように選択肢から一つ選んで回答することができます。ここでは、好きなプログラミング言語は？という設問に対してPythonと回答しています
 -->

---
# 実際の画面
## ホスト側投票中画面

![bg right](host_voting_page.png)
- ゲストの回答がリアルタイムで反映される

<!-- この時ホスト側ではゲストの回答をリアルタイムで閲覧することができます。見にくいですが、先ほどの画像のゲストの回答が反映されているようになっています -->

---
# 実際の画面
## 投票結果表示画面
- chart.jsライブラリで投票結果を描画
- 横軸は選択肢、縦軸に選択肢ごとに投票された数

![bg contain right](guest_mobile_result_page.PNG)

<!--
ホストはこの投票を任意のタイミングで結果を表示することができ、ホストゲスト含め投票結果を見ることができます。 -->

---
# 評価方法
## 実験の手順
- WebSocket上でサーバーがクライアント（ホスト・ゲストユーザー）に送信したデータが、クライアント側に届くまでの時間を計測
- ボサール研所属の学生がゲストユーザーとして参加（実験参加人数：20人）
- サーバーがデータを送信する度にログを残す
  - サーバーが送信した時刻
  - クライアントが受信した時刻
  - 投票ルームに参加しているホスト・ゲスト含めた人数のデータ

<!-- 続いてパフォーマンスを評価するための方法です。評価方法は、WebSocket上でサーバーがクライアントに対して送信したデータがクライアント側に届くまでの時間を計測しパフォーマンスを測ります。データの集計方法として、サーバーがデータを送信する度にログを残します。このとき記録されるデータは、サーバーが送信した時刻、クライアントが受信した時刻、投票ルームに参加しているホスト・ゲスト含めた人数のデータが記録されます。所属しているボサール研所属のゼミナール生がゲストユーザーとして参加し、実際に作成したアプリを使用してもらいました。
 -->

---
# 評価方法
## 記録されたログ（抜粋）
- emitted_at：サーバーが送信した時刻
- received_at：クライアントが受信した時刻
- participants_count：ログを記録した時点での投票ルーム参加人数
![bg right contain](log_data.png)

<!-- 実際に記録されたログはこのような表のようになっており、それぞれemitted_at、received_at、participants_countがサーバー送信した時刻、クライアントが受信した時刻、ログを記録した時点での投票ルームの参加人数を表しています。 -->

---
# 評価方法
## 収集したログデータの扱い

![width:700px](formula.png)
- サーバーの送信からクライアントの受信までの時間の差分（t）を計算
- 比較しやすくするため、msで単位を修正するために 86400000 を差分の時間に乗算（1日 = 86400000ミリ秒）
- 投票ルームに参加していた人数毎にログをグルーピングし、グルーピングされた送信から受信までの時刻の差分の平均を算出

<!-- そして、集計したログごとに計算を行います。サーバーの送信からクライアントのデータの受信までの時間の差分は（t = received_at - emitted_at * 86400000）のように求めます。差分を求めた後は比較を行いやすくするためにms単位に修正しました。最後に投票ルームに参加していた人数毎にログをグルーピングし、グルーピングされた送信から受信までの時刻の差分の平均を算出して、参加人数ごとのパフォーマンスを比較しました。
 -->

---
# 結果
## 実験結果
![bg right contain](experiment_result.png)
- 縦軸：投票ルーム参加者数ごとのデータの送信から受信までの平均ms
- 横軸：参加者数
- 波はあるが人数が増えるほどデータの送信から受信までの時間が増える

<!-- 結果が次にようになりました。縦軸がデータの送信から受信までのm秒、横軸が参加者数を表しています。人数によりデータが届くまでの時間に波はありますが、人数が増えるほどデータの送信までの時刻は伸びており、今回では17人の時が送信までの時間平均が長くなりました。 -->

---
# 考察

- 投票ルームに参加している人数が増加するとサーバーがクライアントにデータを送信するまでの時間は増加する
  - ミリ秒なので人が感覚的にパフォーマンスの低下を認知するほどではない
- WebSocketはサーバーが軸となる双方向通信のため、サーバーへの負担が大きくなる
  - 大人数かつリアルタイムな通信が常時必要なサービスの実装は不向き
  - チャットサービスなどの１体１や数人程度のリアルタイム通信の実装は、サーバーを介して行えるため通信の制御が可能なため、柔軟な実装が可能

<!-- 結果から、投票ルームに参加している人数が増加するとサーバーがクライアントにデータを送信するまでの時間は増加していきます。また、WebSocketはサーバーが軸となる双方向通信のため、サーバーへの負担が大きくなるので、実装するサービス規模により、WebSocketの使用が適切かどうか分かれるように感じました。 -->

---
# まとめ

- WebSocket実装のエコシステムが豊富なので、迅速に開発および実装することが可能
- WebSocketはイベント駆動方式のプロトコルで、双方間の通信が確立すれば自由にデータの送受信が可能
  - 自由度が高い分、イベント名の指定方法やデータ送信のルール等の規則がないとコードが煩雑化する
- 実装したいリアルタイム性によってはWebSocketの使用について吟味する必要あり

<!-- WebSocketはイベント駆動方式のプロトコルのため、自由度高く実装できる反面、イベント名の命名方法などのルールを定める必要がありそうだと感じました。WebSocketの実装は豊富なライブラリなどのおかげで迅速に開発を行うことができました。また、実装したいものによって、使用するか否かを吟味する必要もあることを知りました。
 -->
